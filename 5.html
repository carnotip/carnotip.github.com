<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 11 February 2007), see www.w3.org">
<title>Developer</title>
<meta http-equiv="content-type" content="text/html; charset=us-ascii">
<link rel="stylesheet" media="all" href="docs/docco.css" type="text/css">
<style type="text/css">
 pre.c16 {color:#777;}
 p.c15 {color:black;}
 form.c14 {font: normal 100% Arial, sans-serif;font-size: 10px;}
 a.c13 {display: none;}
 fieldset.c12 {-moz-border-radius: 4px;border-radius: 4px;-webkit-border-radius: 4px;border: 1px solid #ccc;padding-top: 1.5em;margin: .5em 0;background-color: #fff;color: #000;text-align: left;}
 input.c11 {clear: both;width: auto;display: block;margin: 1em 0 1em 5%;}
 div.c10 {float: left;top: -1.4em;padding: 0em .5em 0em .5em;overflow: hidden;width: 90%;margin: 0 5%;clear: both;}
 div.c9 {display: none;margin: 1em 0;padding: 1em .5em .5em 0;font-weight: bold;float: left;top: -1.5em;z-index: 1;width: 80%;background: #E3FBE4;color: #529214;}
 div.c8 {display: none;margin: 1em 0;padding: 1em .5em .5em 0;font-weight: bold;float: left;top: -1.5em;z-index: 1;width: 80%;background: FBE3E4;color: #D12F19;}
 div.c7 {margin: 1.3em 5%;clear: both;overflow: hidden;}
 input.c6 {margin-right: 1.5em;padding: .2em .3em;width: 90%;float: left;z-index: 999;}
 label.c5 {display: block;margin: .3em 0;line-height: 1em;font-weight: bold;}
 div.c4 {text-align: right;font-style: italic;overflow: hidden;color: #000;margin: 0 9% 0 0;}
 legend.c3 {white-space: normal;text-transform: capitalize;font-weight: bold;color: #000;background: #fff;padding: .5em 1em;border: 1px solid #ccc;-moz-border-radius: 4px;border-radius: 4px;-webkit-border-radius: 4px;font-size: 1.2em;}
 p.c2 {background:#ffffaa; padding:10px; text-align:center;}
 a.c1 {color:blue;}
</style>
</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead>
<tr>
<th class="docs">
<h1>Developer</h1>
<span class="small">by Team(<a href="http://twitter.com/carnotweat">Twitter</a> <a href=
"http://carnot.github.com/feeds">Metrics</a> <a href=
"http://angel.co/carnot">Angellist</a>).</span></th>
<th class="code"></th>
</tr>
</thead>
<tbody>
<tr id="section-1">
<td class="docs">
<table border="0">
<tr>
<td>
<h3>&gt;Signal<br>
<br></h3>
</td>
<td><img src=
"https://lh3.googleusercontent.com/-9mTf8xVjzCs/TeCaCIeKJsI/AAAAAAAADnM/HvljqlBi6mE/14284131279.jpg"></td>
</tr>
</table>
<ul>
<span class="inline_editor_value">

<ul>
<a href="http://carnotip.github.com/5.html" target="_blank">Develop</a>

<li><strong>or Say it</strong></li>
</ul>
</span>
</ul>
<p class='c2'><a href='docs/index.html' class='c1'>Deck</a> .</p>
<p>Once in , use the navigation menu in the top-right corner .</p>

<script src="https://gist.github.com/1018655.js"> </script>

 <iframe src="http://checkvist.com/checklists/71479-docs-short-form" scrolling="auto"
width="450" height="600" frameborder="0"></iframe></td>
<td class="code">
<p class='c15'></p>
<table border="0" cellpadding="5" cellspacing="0" width="600">
<tr>
<td align="left" valign="top" width="200">snippets</td>
<td align="left" valign="top" width="200"><img src=
"https://lh4.googleusercontent.com/-rFteJJwtJxk/TY3zFLsW0zI/AAAAAAAADtA/pMHzCxs1mZE/arrow_down_32x32.jpg"></td>
<td align="left" valign="top" width="200">Theory</td>
<td align="left" valign="top" width="200">
<h3>&lt; Noise</h3>
</td>
</tr>
</table>
<pre class='c16'>
</pre>


<h2>Gist 


<body>
  <script language="JavaScript" type="text/javascript">

  <!--

  function PracticeWindow() {

  window.open("try.htm","MainWindow","status,scrolling=yes,resizable,height=540,width=460")

  }

  //-->

  </script><basefont>

  <div class="c1">
   <strong><a name="TOC" id="TOC">Wiki</a></strong></h1>
    <hr size="3">

    <table border="0" cellspacing="0" cellpadding="0">
      <tr>
        <th align="left" valign="top" nowrap>
          <ul>
            <li><a href="#anchor">To begin with</a></li>

            <li><a href="#local">How To</a></li>

            <li><a href="#target">Core concepts</a></li>

            <li><a href="#alert">Advanced topics</a></li>
          </ul>
        </th>

        <th align="left" valign="top" nowrap>
          <ul>
            <li><a href="#back">Updates</a></li>

            <li><a href="#redirect">Roadmap</a></li>

            <li><a href="#mouseover">Tools</a></li>

            
          </ul>
        </th>
      </tr>
    </table><a name="anchor" id="anchor"></a>
    <hr size="3">
  </div>

  <div class="c2">
    <strong>To begin with</strong>
  </div>
  <hr size="3">

  <ul>
    <li>
      <strong>Getting started</strong>
   <table>
<tr>
<td>
</td>
<td>
c
</td>
<td>
</td>
</tr>
<tr>
<td>
JFP  ** 21 **    (3): 309–329, 2011.
</td>
<td>
ł   Cambridge University Press 2011
</td>
<td>
309
</td>
</tr>
<tr>
<td>
doi:10.1017/S0956796811000086
</td>
<td>
</td>
</tr>
</table>

A combinator library for the design of railway track layouts

B A R N E Y S T R A T F O R D

(   e-mail:     barney stratford@fastmail.fm   )

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918825fdf3f2baf421490d341b2d8eedd326e" width="4" height="1" id="zw-1307796198152D4lU3O" style="margin-left: 159.25pt; margin-top: -2pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918821a31f190a7c99a951b4cf2924e9a51b3" width="480" height="1" id="zw-1307796198152ea4mPi" style="margin-left: -0.45pt; margin-top: 21.65pt; position: absolute; z-index: -65534" />

** Abstract **

In the design of railway track layouts, there are only a small number of geometric configurations that are used in practice, and a number of constraints as to how those configurations can be fitted together to create a whole layout. In order to solve these problems, we construct a Haskell combinator library. The library has been used for the design of real-world track layouts.

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918821a31f190a7c99a951b4cf2924e9a51b3" width="480" height="1" id="zw-1307796198153eQZhbu" style="margin-left: -0.45pt; margin-top: 16.65pt; position: absolute; z-index: -65534" />

** 1 Introduction **

Railway preservation is a peculiarly British phenomenon. A preserved railway is e ectively a working museum, o ering the public the chance to see how railways were run in past times. Many of them are operated by steam locomotives that only the older generation can remember in service. Such railways are sta ed almost entirely by volunteers, who relish the chance to get away from their day jobs and help to look after big, beautiful, smelly machines.

The Mid-Norfolk Railway is one such organisation. There has developed a pressing need to be able to e ciently design track layouts to fit within various constraints, such as the amount and shape of land available, and the facilities that are required to be included in the design. There is software available to the professional rail industry to solve such problems, but this is unavailable to a non-profit organisation, making the present work necessary. The opportunity to study the underlying geometry, and to work the problems through ourselves seemed too good to miss, and has resulted in a further “real world” use for functional programming. The methods used here are similar to those used in the industry 20 years ago, before computers were powerful enough to display fancy graphical interfaces.

The first use to which this library has been put is the design of a passing loop. On a single-track railway, it is clearly impossible for trains heading in opposite directions to pass each other. To overcome this, a short double-track section is provided (along with the associated signalling systems) where the trains can pass, thus greatly increasing the number of trains that the line can carry at once (see Figure 1).

Our new passing loop was built at Thuxton, with construction work starting in early 2009. Around 1,000 man-days of volunteer labour were used in the building of the loop and signalling system, and the total cost came to 50,000 UK pounds.

310  <img src="../images/spacer.gif" height="1" id="zw-13077961981548UUQAw" class="zohotab" style="width: 565px" />    B. Stratford

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188249002f4aee630879ae0c19dede5a9422" width="448" height="63" id="zw-13077961981541LuBzk" style="margin-left: 11.35pt; margin-top: 14.5pt; position: absolute; z-index: -65535" />

Fig. 1. A simplistic passing loop, enabling two trains to pass on a single-track railway.

Our library is developed using Haskell (Bird 1998; Peyton Jones 2003), whose elegant syntax makes it attractive for our purposes. Haskell has found a wide application for the design of domain-specific languages, and the present paper continues this theme. In particular, the problems that we solve here can be expressed much more elegantly when functions are first-class objects. The paper also provides a general pattern for combinator libraries that solve numerical problems, particularly in Section 3.

Why did we take this approach to solving the problem? We wanted our library to be able to calculate track layouts based on the constraints that they must satisfy. We want to describe what a layout should look like, or what the end result should achieve, rather than have to say precisely how the layout is to be built. This naturally suggests a declarative style of programming, which is the forte of the functional programming languages. Our declarative approach made it possible to use the system for rapid prototyping, as it is easy to take pre-built sections of track layout and simply attach them together to see what the result looks like.

_ 1.1 A little history _

The system described here has undergone two or three major design changes and hundreds of smaller tweaks to get it into its current form. We began with a very concrete representation of our various datatypes, and special-purpose code to solve each of the constraints that we encountered. It quickly became clear that this method was not flexible enough for the intended purpose, as we were finding it necessary to solve new constraints all the time, and each new situation required new code. It was quickly becoming an unmaintainable mess.

Instead, we have used a very general datatype to describe all our track layouts without needing to go into any special cases. We also built a powerful constraint solver that enables us to specify arbitrary constraints that our layout is to satisfy. We are not limited to solving only the problems that were considered important by the designers.

The generality and flexibility of our system are its key strengths, for every rule has its exceptions, and every general principle will have specific situations in which it does not apply. Much of the domain-specific knowledge that needs to be applied to a layout design comes from experience, judgment or knowledge of the site in question. Human input into the design process is absolutely essential.

In initial versions of this software, we had hoped to use the type system to provide guarantees of the validity of a track layout. For example, a layout is invalid if two adjacent sections of track do not meet up: a train would derail in the gap. When we implemented these kinds of guarantees, we found that it caused the

Railway track layouts  <img src="../images/spacer.gif" height="1" id="zw-1307796198155ncsaXK" class="zohotab" style="width: 520.576px" />    311

program’s complexity to increase, and it became too di cult to read code that was littered with constructors. The ability to produce invalid track layouts is not a great inconvenience, for a glance at the finished design will show up such glaring errors in an instant. Experience has shown that an attempt to produce an invalid layout will usually result in the machine being unable to find a layout that satisfies the constraints. In any case, it would only have been possible to catch the simplest kinds of errors using such methods, and human inspection would still be required to ensure that the many engineering rules are followed.

** 2 A railway track primer **

We begin by giving the basic definitions of the railway-specific technical terms that are used in this paper. The construction of railway track is a diverse subject, with many di erent designs, some experimental, having been used by the various railway companies that have existed throughout history. An authoritative reference is Cope (1993).

_ 2.1 _   _ Plain line _

_ _

·     section of railway track consists of two steel rails mounted on   sleepers   (known as   ties   in the USA) that hold the rails in place. The track is laid on a bed of small, angular stones (known as   ballast   ) that transfer and spread the weight of passing trains to the track bed.

One job of the sleepers is to maintain the   gauge   of the track, which is the distance between the inside surfaces of the rails. In current British practice, the gauge is 1435 mm.

In order to ensure a smooth ride and to reduce wear on the track and trains, it is important that the geometry of the track is maintained. Where the track curves, the outside rail will be higher than the inside (called   cant   ) so that passing trains lean into the curve and there is no net horizontal force on the track.

In order to ensure that a train’s passage is as smooth as possible, it is highly desirable to keep the cant almost constant. When the cant is unchanging over a section of track, the curvature must also remain constant, and so railway tracks are mostly designed using circular arcs and straight line segments.

The real-world situation is a little more complicated than this, however, as the curvature must necessarily change sometimes, for example at the end of a straight section of track. One can’t abruptly change the curvature, for then the cant would also have to change abruptly to match, which isn’t allowed. Instead, the curvature changes linearly from one value to another over a short section of track; this is a   transition curve   . In order to keep things simple, we have not included transition curves in this version of the combinator library although there is no reason why they couldn’t be added at a later date. For the current application, in which the trains will be moving fairly slowly, this is not a serious shortcoming.

312  <img src="../images/spacer.gif" height="1" id="zw-13077961981584mpbgY" class="zohotab" style="width: 565px" />    B. Stratford

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c791882b5ed6d146b4ddb1eb9836f886e2def7b" width="360" height="237" id="zw-1307796198158XXZgZ5" style="margin-left: 1.9pt; margin-top: 15.3pt; position: absolute; z-index: -65535" />

Switches

Common Crossing

Fig. 2. A turnout.

_ 2.2 Switches and crossings _

Two tracks will often be required to converge to a single line, and this is achieved by means of   turnouts   . A turnout consists of two important parts: the   switches   that move to divert a train from one line to another, and a   common crossing   that enables the rails of the two routes to cross each other (see Figure 2).

Switches and crossings come in a variety of standard sizes, and which to be used depends on such factors as the speed of passing trains and the space available. It is possible to manufacture switches and crossings to any required size, but the use of a non-standard size greatly increases the cost and time required. The author only knows of one occasion where this has been necessary (on the London Underground), and layouts are almost exclusively designed with the standard sizes in mind.

** 3 Manipulating circles and straight lines **

The basic elements of a railway track layout are circular arcs and straight line segments. A track layout is formed by connecting several such curves together. This section develops the machinery that we will subsequently use to create and manipulate circles and lines.

Traditionally, circles are specified by giving their centre and radius. When designing track layouts, we do not always know this information. Instead, we may have to specify that an unknown circle is tangent to some given circle, or that it passes through a certain point. We will define functions that allow us to describe circles in terms of the conditions that they must satisfy.

In order to manipulate circles and lines in an e ective manner, it is necessary to make a careful choice of representation. Early versions of our combinator library considered circles and straight lines as separate cases – a very concrete representation.

Railway track layouts  <img src="../images/spacer.gif" height="1" id="zw-1307796198161njd68p" class="zohotab" style="width: 521px" />    313

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918824bb00e0cac637cfc410a11b124d5c29a" width="400" height="400" id="zw-1307796198161n4Hkhi" style="margin-left: 28.35pt; margin-top: 15.8pt; position: absolute; z-index: -65535" />

_ p _  = 1

_ p _  = 1.464

_ p _  = 0

_ p _  = –5.464

_ p _  = –2

Fig. 3. Oriented circles in   2   . Values of  _ p _  vary and  _ a _  =  _ b _  =  _ k _  = 1.

This led to a number of corner cases and increased the amount of calculation that was necessary. Instead, we use a slightly more general description of circles due to Pfei er and van Hook (1993) such that straight lines are merely a special case that does not need separate consideration. Simple continuity arguments can then be applied to prove – for free – that the library behaves correctly when faced with a straight line, without further calculation being necessary. Another useful consequence of the representation is that we only rarely need to use any trigonometric functions.

Hiding these details inside a combinator library means that the end user will not have to think about them, or even be aware that they exist.

_ 3.1 Basics _

We begin by considering how to represent the straight line segments and circular arcs that our layouts will be constructed from. In all that follows, we will use the word ‘circle’ to include straight lines, which can be considered to have infinite radius. Where we wish to exclude straight lines, we will refer to ‘proper circles’. All our circles will be oriented.

<table>
<tr>
<td>
314
</td>
<td>
</td>
<td>
B. Stratford
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
_ r _
</td>
<td>
</td>
<td>
_ θ _
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
(  _ x _  ,  _ y _  )
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
_ d _
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
(0, 0)
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
Fig. 4.
</td>
<td>
Specifying oriented circles and straight lines.
</td>
<td>
</td>
</tr>
<tr>
<td>
Let (  _ p, a, _  2
</td>
<td>
_ b, k _  )  _ _  ∈  _ _  4  _ _  be a non-zero vector. Then, the locus  _ C _
</td>
<td>
(  _ p, a, b, k _  ) of points
</td>
<td>
</td>
</tr>
<tr>
<td>
(  _ x, y _  )   ∈   satisfying
</td>
<td>
_ p _  (  _ x _  2  _ _  +  _ y _  2   )  _ _  −  _ _  2  _ ax _  −  _ _  2  _ by _  +  _ k _  = 0
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</table>

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c791882e311adb194b2397e466f59fa804bb510" width="440" height="199" id="zw-1307796198172FPs17Q" style="margin-left: 2.35pt; margin-top: -249.55pt; position: absolute; z-index: -65535" />  is a circle. In the case where  _ p _  = 0, then it is readily seen that this equation represents a straight line. When  _ p _  =   ₃   0, then the equation can be rearranged to give

₃  _ a _    ₃   2     ₃    _ b _    ₃   2     ₃  _ a _    ₃   2     ₃  _ b _    ₃   2    _ k _   _ x _  −  _ _ _ p _ _ _  +  _ y _  −  _ _ _ p _ _ _  =  _ _ _ p _ _ _  +  _ _ _ p _ _ _  −  _ _ _ p _ _ _  .

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198175UCk1ak" style="margin-left: 106.15pt; margin-top: -5.7pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198175zdfeuH" style="margin-left: 161.95pt; margin-top: -5.7pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c791882861bece77cb77b8c3994aa1975676ec1" width="8" height="1" id="zw-13077961981755N1GJa" style="margin-left: 201.3pt; margin-top: -5.7pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198175wC2FKS" style="margin-left: 239.5pt; margin-top: -5.7pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198175Pn8WHK" style="margin-left: 270.4pt; margin-top: -5.7pt; position: absolute; z-index: -65534" />

This is the equation of a proper circle. When  _ C _  (  _ p, a, b, k _  ) is a proper circle with its centre at (  _ α, β _  ) and of radius  _ r _  , then

<table>
<tr>
<td>
(  _ α, β _  ) =   ₃  _ p _ _ a _   _ , _   _ p _ _ b _    ₃
</td>
<td>
</td>
</tr>
<tr>
<td>
and
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
_ r _  2  _ _  =  _ _  ₃  _ p _ _ a _ _ _  ₃   2
</td>
<td>
+   ₃  _ p _ _ b _    ₃   2
</td>
<td>
−  _ p _ _ k _    .
</td>
</tr>
</table>

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198178yNRSdu" style="margin-left: 188.65pt; margin-top: -63.45pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198178YE4NKy" style="margin-left: 199.85pt; margin-top: -63.45pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198178hNnKbI" style="margin-left: 155.55pt; margin-top: -16.75pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-13077961981786aZlhI" style="margin-left: 193.8pt; margin-top: -16.75pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198178eo9dwh" style="margin-left: 224.7pt; margin-top: -16.75pt; position: absolute; z-index: -65534" />  See Figure 3 for some examples.

Note that  _ C _  (  _ p, a, b, k _  ) =  _ C _  (   −  _ p, _    −  _ a, _    −  _ b, _    −  _ k _  ). We can use this fact to allow us to specify the orientation of our circles. When  _ p > _  0, then we consider the arrow to be pointing anticlockwise, and when  _ p < _  0, then it is clockwise. When  _ p _  = 0, then we have a straight line, and we take the orientation to point in a direction parallel to the vector (  _ b, _    −  _ a _  ).

We introduce a datatype to hold this information.

> data Circle a = Circle \{p, a, b, k :: a\}

We also introduce some simple combinators to build circles. Proper circles are specified by giving the centre and radius, while lines are given by the angle from horizontal and the minimum distance to the origin as in Figure 4.

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918828bb2e4e583030e36d185bf29b85a9353" width="288" height="288" id="zw-1307796198180euYM_L" style="margin-left: -74.95pt; margin-top: 65.35pt; position: absolute; z-index: -65535" />

Railway track layouts  <img src="../images/spacer.gif" height="1" id="zw-1307796198180lVFTd5" class="zohotab" style="width: 520.576px" />    315

·     anticlockwise\_circle :: Double -> Double -> Double -> Circle Double

·     anticlockwise\_circle x y r =

·     Circle 1 x y (x ^ 2 + y ^ 2 - r ^ 2)

·     clockwise\_circle :: Double -> Double -> Double -> Circle Double

·     clockwise\_circle x y r =

·     Circle (-1) (-x) (-y) (r ^ 2 - x ^ 2 - y ^ 2)

·     line :: Double -> Double -> Circle Double

·     line d theta = Circle 0 (-sin theta) (cos theta) (2 \* d)

Finally, we make our   Circle   type into an instance of   Read   and   Show   .

_ 3.2 The Newton–Raphson iteration _

One of the main aims of this combinator library is to be able to express a circle in terms of the properties that it satisfies. For example, we might have surveyed a site (possibly with a theodolite or GPS receiver) and found that an unknown circle passes through a known point (  _ x, y _  ) and is tangent to two known circles  _ c _  1   and  _ c _  2   . Because there may be more than one solution satisfying these constraints, we have to estimate roughly where the solution lies. In Haskell code, we would then wish to say something like:

·     c = find estimate $ satisfying

·     [passing\_through x y,

·     tangent\_to c1,

·     tangent\_to c2]

and expect  _ c _  to be a circle satisfying these constraints.

Each of the constraints can be translated into a function on circles whose value goes to 0 when the constraint is satisfied. This enables us to turn a di cult geometric problem into a less-di cult numerical one (zeroing several functions simultaneously), which can be solved by using a multi-dimensional Newton–Raphson iteration. Although seen only infrequently in undergraduate mathematics courses, this is a natural generalisation of the one-dimensional case that finds the zeros of a single function, and the unfamiliar reader is referred to (Press   et al.   2007).

Why are we going to all the e ort of setting up this numerical algorithm, when it is perfectly possible to produce an exact formula for each of the problems we might wish to solve? In early versions of the library, this was precisely the approach that we took, producing reams of code, for example to solve the problem just given. We found that such exact formulæ became big, ugly and unwieldy rather quickly. Each time a new problem arose, it became necessary to go back to the drawing board and find yet another new formula to solve it. We were spending a considerable amount of time on this and found the whole process somewhat dispiriting.

Using the combinator-based approach, complex problems can be built up from simpler constituent parts, using only a few primitives. This is what functional programming is all about.

| k < 0 = k + x | k >= 0 = k - x

316  <img src="../images/spacer.gif" height="1" id="zw-1307796198185y_2UxG" class="zohotab" style="width: 565px" />    B. Stratford

When we are using a standard mathematical library to calculate trigonometric functions, square roots and even floating-point division, it is easy to forget that these algorithms invariably depend on some kind of iterative process under the bonnet, and that their ‘exact’ calculations are restricted by the machine’s accuracy limits. The results given by the ‘approximate’ methods used throughout this paper are therefore no less valid than the results we would obtain by performing a direct calculation.

3.2.1 Circles: three dimensions or four?

Note that a circle in the plane is specified by giving three coordinates: its centre and radius. Our representation of circles has   four   parameters, and one of these must therefore be redundant. We could perform the Newton–Raphson iteration in four dimensions, finding values of  _ p _  ,  _ a _  ,  _ b _  and  _ k _  for which all the constraints go to zero, but this would ignore the redundancy in our representation of circles. Failing to use all the available information would adversely a ect the convergence. Instead, we will show how we can reduce the problem to three dimensions before performing the iteration.

There are many ways to perform this reduction of dimension. The most important criterion when selecting one is that it must be surjective (up to multiplication by a positive constant). We would also like it to be numerically well-conditioned and to be easy to compute.

Suppose that we initially make a guess that  _ C _  (  _ p, a, b, k _  ) is a circle that is close to the solution to whatever problem we are trying to solve. We will specify an arbitrary circle  _ C _  (  _ p _  ₃    _ , a _  ₃    _ , b _  ₃    _ , k _  ₃   ) by making  _ k _  ₃   into a function of the other three variables, thereby removing a dimension.

When  _ k < _  0, then we define

_ k _  ₃  _ _  −  _ k _  = (  _ p _  ₃  _ _  2  _ _  −  _ p _  2   ) + (  _ a _  ₃  _ _  2  _ _  −  _ a _  2   ) + (  _ b _  ₃  _ _  2  _ _  −  _ b _  2   ).

This defines a paraboloid. Because  _ k < _  0, the origin lies inside the paraboloid and so any straight line that begins at the origin will intersect this paraboloid exactly once.

For positive values of  _ k _  , we need to be more careful, since su ciently large values of  _ k _  will cause this paraboloid to move so that the origin is no longer inside it. We can work around this by negating the left-hand side whenever  _ k _    ₃   0:

−   (  _ k _  ₃   −  _ k _  ) = (  _ p _  ₃     2   −  _ p _  2   ) + (  _ a _  ₃     2   −  _ a _  2   ) + (  _ b _  ₃     2   −  _ b _  2   ).

This gives us our projection function, for suitable types   a   and   b   . As a minor optimisation, we can use the identity  _ x _  2     −    _ y _  2   = (  _ x _    −    _ y _  )(  _ x _  +  _ y _  ) to save operations.

·     circle :: Circle a -> [b] -> Circle b

·     circle (Circle p a b k) [p’, a’, b’] =

·     Circle p’ a’ b’ k’

·     where

·     x = (p’ - p) \* (p’ + p) +

·  <img src="../images/spacer.gif" height="1" id="zw-1307796198194od2ByE" class="zohotab" style="width: 419.376px" />    (a’ - a) \* (a’ + a) + (b’ - b) \* (b’ + b)

·     k’

>

>

Railway track layouts  <img src="../images/spacer.gif" height="1" id="zw-13077961981945O3vPO" class="zohotab" style="width: 520.576px" />    317

By construction, our initial guess  _ C _  (  _ p, a, b, k _  ) is already a point on our paraboloid.

_ 3.3 _   _ Handling derivatives _

_ _

·     constraint in our system is expressed as a function taking a circle to a real number. The real number goes to zero precisely when the constraint is satisfied.

·     set of constraints are all satisfied exactly when all of the functions go to zero simultaneously. In situations where we wish to find the simultaneous zeros of several functions of several variables, there is really only one method available: Newton– Raphson.

The problem with using this method is that we need to know not only the values of the functions, but also all of their partial derivatives. A function on circles takes three values, which we are denoting by  _ p _  ,  _ a _  and  _ b _  . We calculate  _ k _  from these values so we can ensure we have only a three-dimensional problem. We give a Haskell type that can contain not only the value of a function at a point, but also its partial derivatives (Karczmarczuk 1998).

> data Result = R \{value, dp, da, db :: Double\} deriving (Read, Show)

A set of constraints then has a Haskell type isomorphic to   Circle a -> [Result]   for a suitable type   a   .

Since   Result   is really just   Double   with some extra information added on, we can make it an instance of   Eq   and   Ord   .

·     instance Eq Result

·     where

·     x == y = value x == value y

·     instance Ord Result

·     where

·     compare x y = compare (value x) (value y)

Given a pair of   Result   s, we can perform all the basic arithmetic operations using the standard rules of di erentiation. For example,

·     x + y = R (value x + value y) (dp x + dp y)

·     (da x + da y) (db x + db y)

This quickly becomes tedious, however, for we have to give almost identical expressions for   dp   ,   da   and   db   . To ease the pain, we give a helper function that enables us to write the expression for each derivative only once.

·     result :: Double -> ((Result -> Double) -> Double) -> Result

·     result value derivative =

·     R value (derivative dp) (derivative da) (derivative db)

Using this helper function, we can write

·     x \* y = result (value x \* value y)

·     (\\d -> value x \* d y + value y \* d x)

318  <img src="../images/spacer.gif" height="1" id="zw-1307796198201Kg24ZB" class="zohotab" style="width: 565px" />    B. Stratford

or even

> sin x = result (sin (value x)) (\\d -> d x \* cos (value x))

In fact,   Result   is an instance of   Floating   , giving access to the full range of mathematical operations while keeping track of all the partial derivatives with respect to  _ p _  ,  _ a _  and  _ b _  .

3.3.1 Coercions

Any   Double   value can be coerced to a   Result   type by assuming that the value is a constant. Likewise, a constant   Circle Double   can be coerced to a   Circle Result   .

·     coerce\_constant :: Double -> Result

·     coerce\_constant x = R x 0 0 0

·     coerce\_circle :: Circle Double -> Circle Result

·     coerce\_circle (Circle p a b k) =

·     Circle (R p 0 0 0) (R a 0 0 0) (R b 0 0 0) (R k 0 0 0)

To perform these coercions at appropriate times, we create a typeclass. For con-venience, and to avoid clutter later on, our class is a subclass of   Floating   and

Ord   .

·     class (Floating a, Ord a) => CircleType a

·     where

·     coerce\_constant :: Double -> a

·     coerce\_circle :: Circle Double -> Circle a

Both   Double   and   Result   are instances of   CircleType   , with the obvious definitions. This typeclass will be used extensively when we come to dealing with circle transformers in Section 4.1.

_ 3.4 Satisfying constraints _

We have developed all of the machinery that we will use when finding a circle that satisfies some given constraints, so we show how to assemble these parts into a functioning whole.

We have already seen that a constraint has a type isomorphic to   Circle a ->   [Result]   for suitable   a   . Let   c :: Circle a -> [Result]   be a constraint and let   f :: Circle a -> Circle a   be some function on circles. Then   c . f   is a new   constraint, and there are plenty of situations in which we may want to construct such a constraint. For example, at a common crossing, the right-hand rail of one route may cross over the left-hand rail of another at a fixed angle. When a section of track is represented by giving its centre line, then we will have to apply a transformation to both circles and state that the   transformed   circles cross over at the given angle.

Suppose that   a   is   Double   . A problem arises because all of the derivatives in   c . f   may be incorrect, and so the Newton–Raphson iteration may fail to converge on

Railway track layouts  <img src="../images/spacer.gif" height="1" id="zw-1307796198207yTwt_g" class="zohotab" style="width: 520.576px" />    319

the correct value. We have transformed a circle using   f   without applying the Chain Rule for di erentiation.

In fact, the right thing to do is to take   a   to be   Result   , for then we can apply whatever transformations we choose and the derivatives will be calculated correctly.

Observe that circles of type   Circle Double   are known, constant circles, whereas circles of type   Circle Result   are always unknowns that contain the current best estimate. We can therefore make some highly suggestive type synonym declarations.

·     type Known = Double

·     type Unknown = Result

Although a constraint function returns a list of   Result   s, these lists are really rather atomic. It doesn’t make much sense to count their elements, or to split them up. Their ordering is unimportant and it makes no di erence if an element appears more than once. All we want to be able to do is to combine lists of constraint functions together.

·     newtype Results = Rs \{unRs :: [Result]\}

·     satisfying :: [Circle Unknown -> Results] ->

·     Circle Unknown -> Results

·     satisfying constraints = concatRs . getRs

·     where

·     concatRs = Rs . concat . map unRs

·     getRs = flip map constraints . flip ($)

Each step in the Newton–Raphson iteration involves calculating the value and derivatives of all our constraint functions and then applying the inverse of the Jacobian to the column vector of values. To keep the technicalities to a minimum, we won’t go into the details of how this works. A function to perform a typical Newton–Raphson iteration would then be defined as

·     find :: Circle Known -> (Circle Unknown -> Results) -> Circle Known

·     find c@(Circle p a b k) constraints =

·     circle c $ newton\_raphson [p, a, b]

·     (unRs . constraints . circle c)

where   newton raphson   has type

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918822e5c0b891ded279044602e9ea1c03914" width="5" height="1" id="zw-1307796198212oijMob" style="margin-left: 60.5pt; margin-top: -2.45pt; position: absolute; z-index: -65534" />

> newton\_raphson :: [Double] -> ([Result] -> [Result]) -> [Double]

and where   newton raphson first guess constraints   is a list of values that satisfy the constraints. This function has been designed so that it can cope with many of the mishaps that occur in practice. It is not possible to guarantee that newton raphson   can always discover a solution that satisfies the constraints,   however, as they might be contradictory or the initial guess might be too far from a solution. It will always terminate, and it will signal an error if the resulting circle is not close enough to a position where the constraints are satisfied.

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918822e5c0b891ded279044602e9ea1c03914" width="5" height="1" id="zw-1307796198213Q6_BiB" style="margin-left: 84.5pt; margin-top: -81.15pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c791882e930f8f71f4e221e158c1cd5848de4db" width="5" height="1" id="zw-1307796198213EiMmEl" style="margin-left: 156.25pt; margin-top: -81.15pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918825e2265a20e8445d52a35a78b6bfefaa7" width="5" height="1" id="zw-1307796198213o5isYc" style="margin-left: 32pt; margin-top: -42.3pt; position: absolute; z-index: -65534" />

320  <img src="../images/spacer.gif" height="1" id="zw-1307796198213L0ZT9X" class="zohotab" style="width: 565px" />    B. Stratford

In general, it really is necessary to provide an initial estimate for the result, as there are often multiple solutions to the problems we wish to solve. Experience has shown that there are typically two solutions, and we have to distinguish between them.

** 4 Circle combinators **

Everything is now in place to enable us to find circles that satisfy given constraints. We only need the combinators that transform circles and evaluate the constraints.

_ 4.1 _   _ Circle transformers _

_ _

4.1.1     Reversing orientation

Railway track layouts are not, in general, orientable. For example, a triangular junction would enable a train to turn round by doing a three-point turn. As such, a track layout is only   locally   orientable: we can paint arrows on the tracks, but for some layouts it may be inescapable that two tracks converge with their arrows pointing in opposite directions. To construct layouts where this happens, it will be necessary to be able to reverse the orientation of our circles. We have defined circles so this can be achieved by simply negating  _ p _  ,  _ a _  ,  _ b _  and  _ k _  .

·     reverse\_circle :: CircleType a => Circle a -> Circle a

·     reverse\_circle (Circle p a b k) = Circle (-p) (-a) (-b) (-k)

4.1.2 O setting

It is often the case that two railway tracks follow each other side-by-side. We provide a function to o set a given circle by a given amount to the right when facing in the direction of the arrow. The new circle is concentric with the old one, or, in the case of two straight lines, the two are parallel.

Suppose we wish to o set our circle  _ C _  (  _ p, a, b, k _  ) by an amount  _ δ _  , giving the circle  _ C _  (  _ p, a, b, k _  ₃  _ _  ). When the circle is oriented anticlockwise, then we will add  _ δ _  to its  _ _  radius  _ r _  , whereas  _ δ _  will be subtracted from the radius of a clockwise circle. Hence,

_ k _  =  _ _  ₃  _ a _  ₃   2  _ _  +  _ _  ₃  _ b _  ₃   2  _ _  −  _ _ _ r _  2  _ p p p _

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c791882db1bba070d3a1d3d67a46959c2bbf25e" width="8" height="1" id="zw-1307796198218m3ZDbN" style="margin-left: 127.9pt; margin-top: -11.3pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c791882861bece77cb77b8c3994aa1975676ec1" width="8" height="1" id="zw-1307796198218UUVgQm" style="margin-left: 155.95pt; margin-top: -11.3pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198218vfm_BJ" style="margin-left: 194.15pt; margin-top: -11.3pt; position: absolute; z-index: -65534" />

and

_ k _  ₃  <img src="../images/spacer.gif" height="1" id="zw-1307796198218uyrMpz" class="zohotab" /> _ _  ₃  _ a _ _ _  ₃   2  _ _  ₃  _ b _ _ _  ₃   2

_ p _  =  _ _ _ p _ _ _  +  _ _ _ p _ _ _  −  _ _  (  _ r _ _ _  ±  _ _ _ δ _  )   2   .

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918827c3d91f8c1da731dd7d7b6bddff33792" width="11" height="1" id="zw-1307796198220kmg5hU" style="margin-left: 113.45pt; margin-top: -13.65pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198220j2wF9_" style="margin-left: 143.85pt; margin-top: -13.65pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198220eDCads" style="margin-left: 182.1pt; margin-top: -13.65pt; position: absolute; z-index: -65534" />  Expanding the second expression and substituting the first twice yields

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918827bed42c988fd47aa7294f7f9fb397945" width="113" height="1" id="zw-1307796198220MXFKl2" style="margin-left: 157.05pt; margin-top: 7.7pt; position: absolute; z-index: -65534" />

_ k _  ₃  _ _  =  _ k _  ∓  _ _  2  _ δ _ _ _  ₃  _ a _  ₃   2  _ _  +  _ _  ₃  _ b _  ₃   2  _ _  −  _ k _  −  _ _ _ δ _  2   .  _ p p p p p _

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918823a5bac0140ecf7ccaacf1eb36c1fb7ec" width="11" height="1" id="zw-1307796198221Q8AUrV" style="margin-left: 95.15pt; margin-top: -8pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c791882861bece77cb77b8c3994aa1975676ec1" width="8" height="1" id="zw-1307796198221f6BQZf" style="margin-left: 118.25pt; margin-top: -8pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198221PLSWrq" style="margin-left: 165.55pt; margin-top: -8pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198221_XxDCu" style="margin-left: 203.8pt; margin-top: -8pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198221Hj_knk" style="margin-left: 234.7pt; margin-top: -8pt; position: absolute; z-index: -65534" />

We now multiply through by  _ p _  . Note that we add  _ δ _  to the radius when  _ p _  is positive and subtract it when  _ p _  is negative. Hence,   ∓  _ p _  =   −|  _ p _  |   , and the multiplication goes

Railway track layouts  <img src="../images/spacer.gif" height="1" id="zw-130779619822203HXRW" class="zohotab" style="width: 520.576px" />    321

right inside the square root.

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c791882e67516f4bb7401ddcba8f3bff571587d" width="71" height="1" id="zw-1307796198223xaodxT" style="margin-left: 168.95pt; margin-top: 7.9pt; position: absolute; z-index: -65534" />  ₃

_ k _  ₃  _ _  =  _ k _  −  _ _  2  _ δ a _  2  _ _  +  _ b _  2  _ _  −  _ kp _  −  _ pδ _  2

Although we haven’t considered straight lines as a special case, we can prove that this function behaves as expected when faced with one by using a continuity argument at  _ p _  = 0. It is a recurring theme that everything that works correctly on proper circles will also work on straight lines for free.

·     offset\_circle :: CircleType a => Double -> Circle a -> Circle a

·     offset\_circle amount (Circle p a b k) = Circle p a b k’

·     where

·     amount’ = coerce\_constant amount

·     k’ = k - 2 \* amount’ \* sqrt (a ^ 2 + b ^ 2 - k \* p) -

·  <img src="../images/spacer.gif" height="1" id="zw-1307796198225lNOuZy" class="zohotab" style="width: 419.952px" />    p \* amount’ ^ 2

4.1.3 Others

Other operations on circles could include translation, rotation around the origin and scaling. These are little used in practice, so are not discussed further. Implementation of these operations is left as an exercise for the reader.

_ 4.2 _   _ Constraints _

_ _

4.2.1     Passing through a point

Suppose we have surveyed a site and determined that a section of track passes through the point (  _ x, y _  ). We will wish to express this as a constraint in our system.

By definition, the circle  _ C _  (  _ p, a, b, k _  ) passes through (  _ x, y _  ) when

_ p _  (  _ x _  2  _ _  +  _ y _  2   )  _ _  −  _ _  2  _ ax _  −  _ _  2  _ by _  +  _ k _  = 0.

The left-hand side can be used as our constraint function, giving:

·     passing\_through :: Double -> Double -> Circle Unknown -> Results

·     passing\_through x y (Circle p a b k) = Rs [value]

·     where

·     x’ = coerce\_constant x

·     y’ = coerce\_constant y

·     value = p \* (x’ ^ 2 + y’ ^ 2) - 2 \* a \* x’ - 2 \* b \* y’ + k

4.2.2 Common crossings and tangent curves

At a common crossing, the two rails cross over at a fixed, pre-defined angle. We will therefore require a constraint that says that two circles cross at a fixed angle. It is also often necessary to specify that two circles are tangent to each other, which can be achieved as a special case with the angle set to zero. It is not enough that the curves simply touch each other; the orientations also have to match.

322  <img src="../images/spacer.gif" height="1" id="zw-1307796198230OvaUk_" class="zohotab" style="width: 565px" />    B. Stratford

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918824c3b1e2dc5cd93e1ad7864449f1fd531" width="309" height="309" id="zw-1307796198230GMtLto" style="margin-left: 63.15pt; margin-top: 13.15pt; position: absolute; z-index: -65535" />

_ θ _

_ r _  2

_ φ _

_ r _  1

Fig. 5. Oriented circles crossing at a given angle  _ θ _  .

Let  _ C _  (  _ p _  1  _ , a _  1  _ , b _  1  _ , k _  1   ) and  _ C _  (  _ p _  2  _ , a _  2  _ , b _  2  _ , k _  2   ) be two overlapping circles, and let  _ θ _  be the angle at their intersection. If one was to stand at the crossing point, facing in the direction of the arrow of  _ C _  (  _ p _  1  _ , a _  1  _ , b _  1  _ , k _  1   ), then one would have to turn anticlockwise by an amount  _ θ _  to be facing in the direction of the arrow of  _ C _  (  _ p _  2  _ , a _  2  _ , b _  2  _ , k _  2   ).

In Figure 5, note that  _ φ _  =  _ π _    −    _ θ _  in the case where the circles have opposite orientation, and  _ φ _  =  _ θ _  where the orientations are the same. Letting  _ r _  1   and  _ r _  2   be the radii of the circles, the cosine rule therefore gives us that

₃  <img src="../images/spacer.gif" height="1" id="zw-1307796198235gnSI0-" class="zohotab" style="width: 437.624px" />    ₃   2   ₃  <img src="../images/spacer.gif" height="1" id="zw-1307796198235ZAe1m6" class="zohotab" style="width: 397.624px" />    ₃   2

_ a _  1  _ _  −  _ _ _ a _  2  _ _  +  _ _ _ b _  1  _ _  −  _ _ _ b _  2  _ _  =  _ _ _ r _  2  _ _  +  _ _ _ r _  2  _ _  ±  _ _  2  _ r _  1  _ r _  2  _ _  cos  _ _ _ θ _

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918820baba1c15e5489aeecd05de763621fc3" width="13" height="1" id="zw-1307796198237qhkF3V" style="margin-left: 79.75pt; margin-top: 0.1pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188243a9329e326fa64f3e72bae02dd7c5c7" width="13" height="1" id="zw-1307796198237qyYucD" style="margin-left: 103.35pt; margin-top: 0.1pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918820baba1c15e5489aeecd05de763621fc3" width="13" height="1" id="zw-1307796198237nJHFSb" style="margin-left: 145.55pt; margin-top: 0.1pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188243a9329e326fa64f3e72bae02dd7c5c7" width="13" height="1" id="zw-1307796198237nDT1Vv" style="margin-left: 169.15pt; margin-top: 0.1pt; position: absolute; z-index: -65534" /> _ p _  1  _ p _  2  <img src="../images/spacer.gif" height="1" id="zw-1307796198238-P8B-L" class="zohotab" style="width: 417.344px" />   _ p _  1  _ p _  2  <img src="../images/spacer.gif" height="1" id="zw-1307796198238xNQ9iv" class="zohotab" style="width: 417.344px" />    1  <img src="../images/spacer.gif" height="1" id="zw-1307796198238UxDdzo" class="zohotab" style="width: 462.344px" />    2

where the   ±   is positive when the orientations of the circles are opposed and negative when aligned. Multiplying out and cancelling terms gives

<table>
<tr>
<td>
_ a _  1  _ a _  2
</td>
<td>
_ b _  1  _ b _  2
</td>
<td>
_ k _  1
</td>
<td>
_ k _  2
</td>
</tr>
<tr>
<td>
−   2    _ p _  1  _ p _  2
</td>
<td>
−   2    _ p _  1  _ p _  2
</td>
<td>
=   −    _ p _  1
</td>
<td>
−  _ p _  2
</td>
</tr>
</table>

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c791882c1ff10822b5d2520a90b16075f888655" width="25" height="1" id="zw-1307796198241WHNxhe" style="margin-left: 22.85pt; margin-top: -15.55pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188277e0f01522342ea858792d929e0805ea" width="25" height="1" id="zw-1307796198241nO56c4" style="margin-left: 60.35pt; margin-top: -15.55pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188243a9329e326fa64f3e72bae02dd7c5c7" width="13" height="1" id="zw-13077961982413m393q" style="margin-left: 108.4pt; margin-top: -15.55pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918820baba1c15e5489aeecd05de763621fc3" width="13" height="1" id="zw-1307796198241zOW_T7" style="margin-left: 131.95pt; margin-top: -15.55pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188289a38dda7001a8090bd11e7a0d72a39a" width="129" height="1" id="zw-1307796198241ETc-Po" style="margin-left: 123.8pt; margin-top: 0.25pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188289a38dda7001a8090bd11e7a0d72a39a" width="129" height="1" id="zw-1307796198241a2Jbzx" style="margin-left: 229.55pt; margin-top: 0.25pt; position: absolute; z-index: -65534" />  ₃ ₃   2   ₃ ₃   2  <img src="../images/spacer.gif" height="1" id="zw-1307796198241CHEYIk" class="zohotab" style="width: 457.376px" />    ₃ ₃   2   ₃ ₃   2

±   2    _ a _  1     +    _ b _  1     −    _ k _  1    _ a _  2     +    _ b _  2     −    _ k _  2     cos    _ θ _  .    _ p _  1  _ _ _ p _  1  _ _ _ p _  1  _ _ _ p _  2  _ _ _ p _  2  _ _ _ p _  2

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188243a9329e326fa64f3e72bae02dd7c5c7" width="13" height="1" id="zw-1307796198243uAg1B8" style="margin-left: 132.35pt; margin-top: -12.3pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188243a9329e326fa64f3e72bae02dd7c5c7" width="13" height="1" id="zw-1307796198243n8804P" style="margin-left: 174.55pt; margin-top: -12.3pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188243a9329e326fa64f3e72bae02dd7c5c7" width="13" height="1" id="zw-1307796198243UZzSJl" style="margin-left: 209.45pt; margin-top: -12.3pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188243a9329e326fa64f3e72bae02dd7c5c7" width="13" height="1" id="zw-1307796198244Kz57J1" style="margin-left: 238.1pt; margin-top: -12.3pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918820baba1c15e5489aeecd05de763621fc3" width="13" height="1" id="zw-1307796198244MoOiuf" style="margin-left: 280.3pt; margin-top: -12.3pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c791882e6586b0e3ef4893346914deeb361e600" width="13" height="1" id="zw-1307796198244TpIXlD" style="margin-left: 315.2pt; margin-top: -12.3pt; position: absolute; z-index: -65534" />

We now rearrange and multiply through by  _ p _  1  _ p _  2   . Recall that the   ±   sign is positive when  _ p _  1  _ p _  2   is negative and negative when  _ p _  1  _ p _  2   is positive. Hence,   ±  _ p _  1  _ p _  2   =   −|  _ p _  1  _ p _  2   |   and so we can multiply right into the square roots, giving

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918820f85fe2df1daed53214960387b146490" width="81" height="1" id="zw-1307796198245QSrLVH" style="margin-left: 95.2pt; margin-top: 8.25pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918828dad6a9076d7196c26b134b8aca550de" width="81" height="1" id="zw-13077961982453EglH4" style="margin-left: 165.15pt; margin-top: 8.25pt; position: absolute; z-index: -65534" />  ₃  <img src="../images/spacer.gif" height="1" id="zw-1307796198245FoQcow" class="zohotab" style="width: 469.344px" />    ₃

_ k _  1  _ p _  2  _ _  +  _ k _  2  _ p _  1  _ _  + 2  _ a _  2   1  _ _  +  _ b _  2   1  _ _  −  _ k _  1  _ p _  1  _ a _  2   2  _ _  +  _ b _  2   2  _ _  −  _ k _  2  _ p _  2  _ _  cos  _ θ _  −  _ _  2  _ a _  1  _ a _  2  _ _  −  _ _  2  _ b _  1  _ b _  2  _ _  = 0.

We can use the left-hand side of this equation as the constraint function for the Newton–Raphson iteration, giving the following code:

Railway track layouts  <img src="../images/spacer.gif" height="1" id="zw-1307796198248r9IRNK" class="zohotab" style="width: 520.576px" />    323

·     crossing\_angle :: Double -> Circle Known -> Circle Unknown ->

·     Results

·     crossing\_angle theta c1 c2 = Rs [value]

·     where

·     Circle p1 a1 b1 k1 = coerce\_circle c1

·     Circle p2 a2 b2 k2 = c2

·     sqrt1 = sqrt (a1 ^ 2 + b1 ^ 2 - k1 \* p1)

·     sqrt2 = sqrt (a2 ^ 2 + b2 ^ 2 - k2 \* p2)

·     value = k1 \* p2 + k2 \* p1 - 2 \* a1 \* a2 - 2 \* b1 \* b2 +

·  <img src="../images/spacer.gif" height="1" id="zw-1307796198251HHggGZ" class="zohotab" style="width: 419.952px" />    2 \* sqrt1 \* sqrt2 \* coerce\_constant (cos theta)

The constraint that two circles are tangent to each other is a special case of this:

·     tangent\_to :: Circle Known -> Circle Unknown -> Results

·     tangent\_to = crossing\_angle 0

4.2.3     Fixed radius

·     constraint that is often required is that the radius of the curve is fixed at some

pre-defined value. The radius  _ r _  of  _ C _  (  _ p, a, b, k _  ) is given by

_ r _  2  _ _  =  _ _  ₃  _ a _ _ _  ₃   2  _ _  +  _ _  ₃  _ b _ _ _  ₃   2  _ _  −  _ _ _ k _ _ _  .  _ _ _ p p p _

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c791882861bece77cb77b8c3994aa1975676ec1" width="8" height="1" id="zw-13077961982542wL1OY" style="margin-left: 155.55pt; margin-top: -11.35pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198254JQ3cK2" style="margin-left: 193.75pt; margin-top: -11.35pt; position: absolute; z-index: -65534" /> <img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c79188200dce54222172eb46f0082041756b4d2" width="8" height="1" id="zw-1307796198254EyU-KO" style="margin-left: 224.65pt; margin-top: -11.35pt; position: absolute; z-index: -65534" />

Rearranging this gives us

<img src="/image.do?imgurl=c783dc90dd15d9c1506a36700719a5974e87eb4ca863fb8f4e27f3933c7918821dbd9cfebe6573f57bf7fd7cb930ed20" width="71" height="1" id="zw-1307796198254yV9PJz" style="margin-left: 172.1pt; margin-top: 4.75pt; position: absolute; z-index: -65534" />  ₃

_ rp _  =  _ _  ±  _ a _  2  _ _  +  _ b _  2  _ _  −  _ kp _  .

When  _ r _  is positive, then we get an anticlockwise circle when  _ p _  is also positive, and hence, when we take the positive square root. Similarly, we take the negative square root when we wish to obtain a clockwise circle. This gives us our constraint functions.

·     anticlockwise\_radius :: Double -> Circle Unknown -> Results

·     anticlockwise\_radius r (Circle p a b k) = Rs [value]

·     where

·     r’ = coerce\_from\_double r

·     value = r’ \* p - sqrt (a ^ 2 + b ^ 2 - k \* p)

·     clockwise\_radius :: Double -> Circle Unknown -> Results

·     clockwise\_radius r (Circle p a b k) = Rs [value]

·     where

·     r’ = coerce\_from\_double r

·     value = r’ \* p + sqrt (a ^ 2 + b ^ 2 - k \* p)

The constraint that ensures we have a straight line is simply  _ p _  = 0.

·     is\_line :: Circle Unknown -> Results

·     is\_line (Circle p a b k) = Rs [p]

324  <img src="../images/spacer.gif" height="1" id="zw-1307796198258hMYTHz" class="zohotab" style="width: 565px" />    B. Stratford

4.2.4 Concentric circles

We will sometimes need to be able to express the constraint that two sections of track follow each other side-by-side: they are concentric. Two circles  _ C _  (  _ p _  1  _ , a _  1  _ , b _  1  _ , k _  1   ) and  _ C _  (  _ p _  2  _ , a _  2  _ , b _  2  _ , k _  2   ) are concentric precisely when the vectors (  _ p _  1  _ , a _  1  _ , b _  1   )  _ T _ _ _  and (  _ p _  2  _ , a _  2  _ , b _  2   )  _ T _ _ _  are collinear.

Let  _ P _  be the plane passing through the point (  _ p _  1  _ , a _  1  _ , b _  1   )  _ T _  and perpendicular to the line joining that point to the origin. Let  _ x _  be the real number such that  _ x _  (  _ p _  2  _ , a _  2  _ , b _  2   )  _ T _  lies on the plane  _ P _  . We can readily see that the two vectors are collinear when

<table>
<tr>
<td>
_ x _
</td>
<td>
_ a _ _ p _  2   2
</td>
<td>
=
</td>
<td>
</td>
<td>
_ a _ _ p _  1   1
</td>
<td>
.
</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>
</td>
<td>
_ b _  2
</td>
<td>
</td>
<td>
</td>
<td>
_ b _  1
</td>
<td>
</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>
that   It is easily shown that    _ x _    =     |   (  _ p _  1  _ , a _  1  _ , b _  1   )  _ T _    |   2  _ / _    (  _ p _  1  _ , a _  1  _ , b _  1   )  _ T _   _ . _  (  _ p _  2  _ , a _  2  _ , b _  2   )
</td>
<td>
, which gives us
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
_ p _  1   2  _ _  +  _ a _  1   2  _ _  +  _ b _  1   2
</td>
<td>
</td>
<td>
_ a _ _ p _  2   2
</td>
<td>
= (  _ p _  1  _ p _  2   +  _ a _  1  _ a _  2   +  _ b _  1  _ b _  2   )  _ a _ _ p _  1   1
</td>
<td>
.
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
_ b _  2
</td>
<td>
</td>
<td>
_ b _  1
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</table>

This rearranges to

_ p _  2   (  _ a _  2   1  _ _  +  _ b _  2   1   )  _ _  −  _ p _  1   (  _ a _  1  _ a _  2  _ _  +  _ b _  1  _ b _  2   )

_ a _  2   (  _ p _  2   1  _ _  +  _ b _  2   1   )  _ _  −  _ a _  1   (  _ p _  1  _ p _  2  _ _  +  _ b _  1  _ b _  2   ) = 0,  _ b _  2   (  _ p _  2   1  _ _  +  _ a _  2   1   )  _ _  −  _ b _  1   (  _ p _  1  _ p _  2  _ _  +  _ a _  1  _ a _  2   )  _ _

giving us our constraint functions. Note that we have   three   functions, when the problem of positioning the centre of the circle is a   two   -dimensional problem. This is because these three constraints are not independent of each other, but any pair of constraints is independent. We have designed our Newton–Raphson iteration to be able to cope with this: it simply deals with it gracefully by throwing away the redundant constraint.

·     concentric\_with :: Circle Known -> Circle Unknown -> Results

·     concentric\_with c1 c2 = Rs [value1, value2, value3]

·     where

·     Circle p1 a1 b1 k1 = coerce\_circle c1

·     Circle p2 a2 b2 k2 = c2

·     value1 = p2 \* (a1 ^ 2 + b1 ^ 2) - p1 \* (a1 \* a2 + b1 \* b2)

·     value2 = a2 \* (p1 ^ 2 + b1 ^ 2) - a1 \* (p1 \* p2 + b1 \* b2)

·     value3 = b2 \* (p1 ^ 2 + a1 ^ 2) - b1 \* (p1 \* p2 + a1 \* a2)

We can also give a special case for directly specifying the centre point:

·     centred\_at :: Double -> Double -> Circle Unknown -> Results

·     centred\_at x y = concentric\_with (Circle 1 x y 0)

Railway track layouts  <img src="../images/spacer.gif" height="1" id="zw-13077961982786sAMbq" class="zohotab" style="width: 520.576px" />    325

_ 4.3 Examples _

Having seen these various combinators for transforming circles and for specifying constraints that they must satisfy, we give a few small examples to illustrate how they can be combined.

4.3.1 Creating a small layout

Suppose that we have surveyed a site and found that a particular section of track has radius of curvature  _ r _  and passes through points (  _ x _  1  _ , y _  1   ) and (  _ x _  2  _ , y _  2   ). Suppose we wish to orient the circle so that the rotation is in a clockwise direction as we move from the first to the second point. Then, we can calculate where this section of track lies as follows:

·     circle1 :: Circle Known

·     circle1 = find guess1 $ satisfying

·     [passing\_through x1 y1,

·     passing\_through x2 y2,

·     clockwise\_radius r]

Suppose the this circle adjoins a straight line that passes through point (  _ x, y _  ). Then, the straight line is specified as:

·     circle2 :: Circle Known

·     circle2 = find guess2 $ satisfying

·     [tangent\_to circle1,

·     passing\_through x y,

·     is\_line]

Now suppose that these two circles are actually on a double-track section of line. Standard practice is to separate adjacent lines by 3.405 m.

> [circle1’, circle2’] = map (offset\_circle 3.405) [circle1, circle2]

4.3.2 Over- and under-specifying circles

The constraint solver is designed so that it can handle under- or over-specified circles, providing the specification is self-consistent.

·     circle3 :: Circle Known

·     circle3 = find (clockwise\_circle 2 0 2) $ satisfying

·     [tangent\_to (clockwise\_circle 1 1 1),

·     tangent\_to (clockwise\_circle 3 3 1),

·     tangent\_to (clockwise\_circle 5 1 1),

·     clockwise\_radius 3,

·     clockwise\_radius 3]

When a circle is under-specified, the result is a circle that satisfies the constraints and is in some sense close to the initial estimate.

326  <img src="../images/spacer.gif" height="1" id="zw-1307796198284YkcCqn" class="zohotab" style="width: 565px" />    B. Stratford

·     circle4 :: Circle Known

·     circle4 = find (clockwise\_circle 2 0 2) $ satisfying

·     [anticlockwise\_radius 1]

This facility comes into its own when trying to find an initial estimate of a solution but one of the constraints is being awkward: we can temporarily omit the bad constraint from our list and find a circle that satisfies the remaining constraints. This then becomes the initial estimate for the problem that includes the di cult constraint.

4.3.3 More complicated relationships

Imagine that a site has a manhole at known position (  _ x, y _  ) and that we want to specify that the track passes exactly  _ d _  metres away from the manhole. How do we write this constraint?

·     near\_manhole :: Double -> Double -> Double ->

·     Circle Unknown -> Results

·     near\_manhole x y d = passing\_through x y . offset\_circle d

We are taking the   unknown   circle, o setting it, and specifying that the transformed unknown circle passes through the known point.

4.3.4 The user’s perspective

The end user of our system does not necessarily know anything about how we’re representing circles. There’s no hint of the underlying mechanism by which the calculations are performed. As we can see from these examples, we only have to tell the system about the relationship between the various elements that the layout is built from. We can even manipulate unknown circles if we wish, and the system will happily deal with them in an appropriate manner. Our language is strongly compositional, with no side e ects.

** 5 PDF file generation **

Having calculated the layout of a section of railway track, we want a graphical representation of it. Adobe’s PDF (Adobe Systems Inc. 2000) seems like a suitable format, being freely available for use and elegantly designed. This paper is not the place to discuss the technical details of the PDF format: the reader is referred to Adobe Systems (2000) instead.

Most of the work of writing to the PDF file will be handled by a plotting monad, enabling us to say, for example

<table>
<tr>
<td>
> main =
</td>
<td>
plotPDF plotter\_settings $ do
</td>
</tr>
<tr>
<td>
>
</td>
<td>
colour Red
</td>
<td>
-- Change the colour of the plot.
</td>
</tr>
<tr>
<td>
>
</td>
<td>
plot
</td>
<td>
[circle1, circle2, etc]
</td>
<td>
-- Plot list of tangent circles.
</td>
</tr>
<tr>
<td>
>
</td>
<td>
mark
</td>
<td>
x y
</td>
<td>
-- Put a cross on the map at
</td>
</tr>
<tr>
<td>
>
</td>
<td>
</td>
<td>
</td>
<td>
-- these coordinates.
</td>
</tr>
<tr>
<td>
>
</td>
<td>
plot\_circle circle3
</td>
<td>
-- Plot a single circle.
</td>
</tr>
</table>

Railway track layouts  <img src="../images/spacer.gif" height="1" id="zw-1307796198290YFIU07" class="zohotab" style="width: 520.576px" />    327

The details of these functions will be elided, as they are not conceptually di cult. For completeness, we will simply give a type signature and explanation of what they do.

Because there is no Haskell PDF package available at present that is capable of modifying a PDF file,   plotPDF   is rather primitive and requires the PDF file to be specially prepared. This is discussed further in the comments in the downloadable code.

In order for the plotter to produce its output, it must be informed of various pieces of information, such as the name of the file to plot to, the position of the origin, which way is north, and the scale of the plot.

·     data PlotterSettings = PlotterSettings \{file :: FilePath,

·     origin :: (Double, Double), north :: Double, scale :: Double\}

We then convert our plotting monad into an IO computation by using   plotPDF   :

> plotPDF :: PlotterSettings -> Plot a -> IO a

_ 5.1 Plotting commands _

When we wish to plot a section of track onto the map, we will pass a list of circles to the   plot   function. All adjacent circles in the list are required to be tangent to one another. The result will be a PDF plot of those circles, joined at their tangent points.

> plot :: [Circle] -> Plot ()

As well as plotting the railway lines, it was found useful to be able to change the colour of the plot. This enhances the clarity of the resulting plot and can be used to convey further information about what is to be built. In common usage, black represents track that will not be a ected by construction works, while green is for track that will be removed and red is for track that will be added. (Think: red stops and green goes.)

·     data Colour = Red | Green | Blue | Purple | Black | Grey | Brown

·     deriving (Read, Show, Eq)

·     colour :: Colour -> Plot ()

It proved to be very useful to be able to mark points and circles onto the plot for debugging purposes. This was particularly true when trying to find initial estimates for the Newton–Raphson iteration. It also helped a great deal when the iteration refused to converge – often, plotting a few circles showed that a solution was impossible. Even when the iteration did converge, it was reassuring to be able to check that it had converged on the intended solution.

·     mark :: Double -> Double -> Plot ()

·     plot\_circle :: Circle -> Plot ()

328  <img src="../images/spacer.gif" height="1" id="zw-1307796198293R9bZdz" class="zohotab" style="width: 565px" />    B. Stratford

** 6 Conclusion **

The practical need for a library for the design of railway track layouts has led to the use of Haskell for the purpose. A functional programming language is ideally suited for the task, as it enables us to express the relationships between the various track layout components in a clean manner. The system described here facilitates the complete process of designing a track layout, including a wide range of combinators to cover most situations that arise in practice. It has been used ‘for real’ in the design of the passing loop at Thuxton and in other places as well.

It came as quite a surprise when we realised how to represent circles and straight lines in the uniform manner described in Section 3. Previously, we had been representing these as two separate cases using an algebraic datatype. Our case-free representation made it possible to specify and solve arbitrary constraints using our Newton–Raphson iterator, and this proved to be the key step in the development of our package. A consequence of this is that we don’t need to use Haskell’s pattern-matching facility at all: each datatype has a single constructor. The problem is that straight lines are a limiting case of proper circles, whereas algebraic datatypes would tend to treat the two cases entirely separately and ignore the continuity that exists in this situation.

A key benefit of the use of a Newton–Raphson iteration has been that our constraints can be used in arbitrary combinations. We can create new constraints by applying transformations to existing ones, and we can even introduce completely novel constraints that were not conceived of when the package was designed – all without modifying the underlying constraint solver. It has been a recurring theme during the development of the software that attempting to produce exact solutions to problems usually resulted in overwhelming complexity, whereas our approximate solutions are highly accurate and o er many practical benefits.

We have given an illustration of how the Newton–Raphson method can be used, in general, for finding the zeros of a function without having to explicitly calculate all of the derivatives by hand. This saves a great deal of time spent debugging and is much more reliably correct. Although the method is applied to just a single problem here, a large and important class of numerical constraint problems can be solved using these methods.

Importantly, the design of this software enables its use for rapid prototyping. Typically, the user would create a rough layout that may not satisfy all of the requirements, plot the PDF, and then, successively refine. Even for such a simple layout as Thuxton, this cycle was repeated many hundreds of times to experiment with the various di erent options that were available to us. ‘What would happen if I were to put that there instead of here?’ ‘Could I use a bigger one of those?’ ‘How sharp would that curve have to be?’

The code described in this paper can be downloaded from the JFP web site, along with the actual plans used at Thuxton. Photos of the construction of the passing loop (including some by the author) can be found at   http://www.mnr.org.uk/photos/   thuxton/   .

Railway track layouts  <img src="../images/spacer.gif" height="1" id="zw-1307796198295DNxtDr" class="zohotab" style="width: 521px" />    329

** Acknowledgments **

Thanks to Ralf Hinze and Colin Runciman for their helpful comments on earlier drafts of this paper.

** References **

Adobe Systems (2000)   PDF Reference   . Adobe Press.

Bird, R. (1998)   Introduction to Functional Programming Using Haskell   . 2nd ed., Prentice Hall. Cope, G. H. (1993)   British Railway Track   . 6th ed., Permanent Way Institution. Karczmarczuk, J. (2001) Functional di erentiation of computer programs.   Higher-Order and

Symb. Comput   ,    ** 14 **  (1), 35–57.

Peyton Jones, S. (ed) (2003)   Haskell 98 Language and Libraries—The Revised Report   . Cambridge, England, UK: Cambridge University Press.

Pfei er, R. E. & van Hook, C. (1993) Circles, vectors, and linear algebra.   Math. Mag.   ,  ** 66 **  (2), 75–86.

Press, W. H., Teukolsky, S. A., Vetterling, W. T. & Flannery, B. P. (2007)   Numerical Recipes   . 3rd ed., Cambridge, England, UK: Cambridge University Press.

[  PDF to Word  ][1]

----

  [1]: http://pdfonline.blogspot.com
  <p><strong>1</strong><br>
  <a href="file:///C:/">2</a></p>

  <p><strong>3</strong></p>

  <p><strong><em><a href="#TOC">To the Table of Contents</a></em></strong> <a name=
  "target" id="target"></a></p>
  <hr size="3">

  <div class="c1">
    <span class="c3">Core concepts</span><strong><br>
    <span class="c4">Index</span></strong>
  </div>
  <hr size="3">

  <p><strong>More</strong><br>
  </p>

  <p><strong>1</strong><br>
  <a href="index.htm" target="main">1.1</a></p>

  <p><strong>2</strong></p>

  <p><strong><em><a href="#TOC"> Table of Contents</a></em></strong> <a name=
  "alert" id="alert"></a></p>
  <hr size="3">

  <div class="c2">
    <strong>Advanced topics</strong>
  </div>
  <hr size="3">

  <ul>
    <li>
      <strong>@RL</strong><br>
      

      <p><strong>1</strong><br>
      <a href="#TOC" onclick="(alert('this will take you to the top!'))">To the Table of
      Contents</a></p>
    </li>

    <li>
      <strong>2</strong><br>
      

      <p><strong>3</strong><br>
      <a href="#TOC" onclick="(confirm('this will take you to the top!'))">To the Table
      of Contents</a></p>
    </li>

    <li>
      <strong>4</strong><br>
      
      <p><strong>5</strong><br>
      <a href="#TOC" onclick="(x=prompt('please enter your name: ', 'Default Text'))"> Table of Contents</a></p>
    </li>
  </ul>

  <p><a name="back" id="back"></a></p>
  <hr size="3">

  <div class="c2">
    <strong>updates</strong>
  </div>
  <hr size="3">

  <p><strong>6</strong><br>
 </p>

  <p><strong>7</strong><br>
  <a href="javascript:history.back()">Back</a></p>

  

  <p><strong><em><a href="#TOC">Table of Contents</a></em></strong> <a name=
  "redirect" id="redirect"></a></p>
  <hr size="3">

  <div class="c2">
    <strong>Roadmap</strong>
  </div>
  <hr size="3">

  <p><strong>1</strong><br>
 </p>

  <p><strong>2</strong><br>
  <a href="refresh.htm">1</a>.</p>

  <p><strong><em><a href="#TOC">Table of Contents</a></em></strong> <a name=
  "mouseover" id="mouseover"></a></p>
  <hr size="3">

  <div class="c2">
    <strong>Tools</strong>
  </div>
  <hr size="3">

  <p><strong>1</strong><br>
  </p>

 


   Later
  </div>
</body>


<script src="https://gist.github.com/1018652.js"> </script>
<iframe src="http://checkvist.com/checklists/72681-docs-long-form" scrolling=
"auto" width="800" height="1500" frameborder="0"></iframe></h2>
</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>
